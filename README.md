# ProgettoSO(definitivo)
In questa implementazione, l'idea di base prevede che l'immagine di memoria del disco debba contenere tre elementi fondamentali:
     1. Un'array di data_block, di dimensione MAX_BLOCKS, denominato data_table dove ciascun data_block è semplicemente un'array di char, di dimensione BLOCK_SIZE, il quale simboleggia la memoria posta a disposizione per ogni file.

     2. Un'array di dir_entry, di dimensione MAX_ENTRIES, denominato dir_entry dove ogni dir_entry rappresenta di fatto un FCB, contenente quindi tutti gli elementi in grado di determinare in maniera univoca un file/directory.

     3. Un'array di fat_entry, di dimensione MAX_BLOCKS, denominato fat_table, dove ogni fat_entry viene rappresentato per semplicità come un intero, usato per tenere traccia di zone libere, attraverso il valore -1, oppure di zone occupate da eventuali file o directory (-2 o altri).

Inoltre, nell'implementazione è possibile individuare due strutture dati cruciali per il corretto funzionamento del programma, ovvero il disco virtuale, il quale permette di operare sull'immagine di memoria, e il FileHandle, richiesto dalle specifiche di progetto il quale permette di operare sui file. Infine, è presente anche una struttura dati la quale verrà utilizzata esclusivamente per la funzione listDir, ovvero il dir_array: essa, come è facilmente intuibile dal nome, risulta essere un vettore di dir_entry.

Nella funzione startFAT, si può osservare l'inizializzazione della struttura dati principale, su cui poggia l'intero filesystem: l'immagine di memoria. Prendendo come input il nome da assegnare a tale elemento, viene inizialmente allocata memoria per contenere tutte le strutture dati contenute al suo interno, tramite malloc. In più, viene aperto il file descriptor e adattato alle dimensioni del disco virtuale (open + ftruncate). Inoltre, viene inizializzato il buffer di memoria contenente il disco attraverso la mmap. Infine, viene inizializzata la tabella fat (la quale conterrà tutti indici di tipo UNUSED) ed eseguito il setup della directory di root, la quale verrà posta anche come directory di lavoro corrente.

Nella funzione killFAT, vengono eseguite di fatto le operazioni inverse di quelle fatte nella startFAT: vengono resettate le varie tabelle presenti nell'immagine di memoria del disco, viene deallocata la zona di memoria associata, viene chiuso il file descriptor e, infine, viene "liberato" l'immagine di memoria, attraverso la free.

Per quanto riguarda la funzione createFile, essa si basa sul valore assunto da due indici, i quali rappresentano rispettivamente la posizione in cui si trova, eventualmente, il file all'interno della tabella delle dir_entry e la prima locazione libera sempre all'interno di essa. In base al loro valore, vengono eseguite diverse operazioni:
     1. Se entrambi sono uguali a -1, ciò significa che il file non è stato individuato e non vi è spazio libero all'interno della tabella delle dir_entry, per cui è necessario ritornare un errore.

     2. Nel caso in cui il primo risulta essere diverso da -1, ciò significa che il file è stato individuato ed è necessario creare un FileHandle, in cui il campo dir_entry del FileHandle sarà uguale alla posizione del file. 
     
     3. Altrimenti, verrà creato un FileHandle in cui il campo dir_entry sarà uguale alla prima locazione libera.

Nella seconda e nella terza ipotesi, è comunque necessario generare una entry all'interno della dir_table: nel primo caso, viene chiamata la funzione createKnownEntry, la quale prende in input anche la posizione del primo blocco relativo al file mentre nel secondo caso viene chiamata la funzione createEntry. In entrambe le funzioni, viene inizializzato il nuovo entry da posizionare all'interno della dir_table con alcune sostanziali differenze: nella createKnownEntry, il campo first_fat_block sarà uguale al posizione del file all'interno della fat_table mentre nel secondo sarà uguale alla prima posizione libera disponibile. Inoltre, nella createKnownEntry, viene modificato il campo relativo al next_fat_block del primo blocco relativo al file (posto uguale al campo first_fat_block dell'entry appena creato). Dopo aver inizializzato la entry, è necessario andare a modificare anche il campo relativo ai figli della parent directory dell'entry.

Nella funzione createDir, viene eseguito il controllo sulla posizione della directory e l'individuazione della prima locazione libera all'interno della tabella delle dir_entry. In base a tali valori, si eseguono differenti operazioni:

     1. Se entrambi sono uguali a -1, ciò significa che la directory non è stata individuata e non è presente una locazione libera all'interno della tabella delle dir_entry, per cui è necessario stampare un errore.

     2. Se il primo indice è diverso da -1, ciò signfica che la directory esiste, per cui non è necessario creare una entry per essa. Altrimenti, si ritorna l'esito della funzione createEntry.

La funzione eraseFile si basa, in maniera simile, sul funzionamento della createFile: inizialmente, viene ricercato il file da eliminare nella tabella delle dir_entry: se l'indice relativo alla sua posizione risulta essere negativo, allora ciò significa che tale elemento non è stato individuato ed è necessario ritornare errore. In caso contrario, è necessario andare a liberare le sezioni del fat_table occupate dal file, così come risulta necessario pulire anche la sezione dei figli relativa alla directory padre dell'entry in questione. Infine, si deallocano l'entry e il relativo FileHandle.

Il funzionamento relativo alla eraseDir risulta essere analoga alla eraseFile, ad eccezione della deallocazione del FileHandle.

Nella funzione changeDir, si eseguono inizialmente dei controlli sul nome della directory fornito in input:
     1. Se il nome della directory risulta "..", è necessario spostarsi all'interno della parent directory, ad eccezione nel caso in cui la current working directory sia quella di root: in tal caso, è necessario ritornare un errore.

     2. Se il nome della directory risulta essere "\", è necessario spostarsi direttamente nella directory di root.

     3. In caso contrario, si esegue una ricerca all'interno della tabella delle dir_entry per individuare l'indice corrispondente alla directory interessante: se la si trova, ci si sposta. Altrimenti, è necessario stampare un errore.

Nella funzione listDir, viene inizialmente allocata memoria necessaria per il dir_array, la quale conterrà la directory corrente e tutti i suoi figli. Dopo aver stampato tutte le informazioni che contraddistinguono la directory corrente, si passa a scandire tutti i suoi figli (diversi da NULL) i quali verranno inseriti negli appositi indici del vettore, dopo la stampa delle loro informazioni caratteristiche.

Nella funzione FAT_write, viene inizialmente verificato che la modalità di accesso contenuta all'interno del FileHandle permetta la scrittura dei file: in caso contrario, si ritorna erroe. In caso contrario, si procede con l'inizializzazione delle variabili ausiliarie necessarie per la gestione della scrittura e l'individuazione del blocco dati associato all'entry contenuto nel FileHandle: tuttavia, nel caso in cui la posizione del puntatore superi la dimensione massima del buffer, è necessario passare al buffer successivo e, nel caso in cui non lo si trovi, è necessario ritornare un errore. A questo punto, si è pronti per l'operazione di scrittura vera e propria, la quale ricorda le scritture eseguite tramite shared memory in cui, tramite ciclo while con condizione in cui i byte scritti siano minori della dimensione del buffer da scrivere, si spostano i byte dal buffer fornito al blocco dati andando ogni volta ad incrementare la posizione del puntatore e i byte scritti. Nel caso in cui si vada a sforare i limiti del buffer, è necessario modificare la posizione del puntatore, eseguendo il modulo con la dimensione massima del buffer, aumentare il contatore relatio ai blocchi ripetuti e cercare un nuovo buffer dati libero. Infine, è necessario aumentare la dimensione del file incrementando quest'ultimo con il numero di caratteri scritti, modificare l'indice relativo al blocco dati e quello della posizione contenuti nel FileHandle.

All'interno della funzione FAT_read vengono eseguite le stesse operazioni preliminari descritte nella FAT_write: nell'operazione di lettura, si verifica lo spostamento inverso di byte, ovvero dal buffer dati dell'entry a quello fornito in input. Inoltre, nel caso in cui si arriva alla dimensione massima del buffer, non si esegue l'operazione di modulo ma basta semplicemente azzerare il puntatore.

Nella funzione FAT_seek, si esegue un primo controllo sul tipo di whence fornito: in particolare, se si tratta di un tipo non corretto, è necessario stampare un errore. Nel caso in cui si tratta di SEEK_SET, non è possibile muovere all'indietro il puntatore mentre nel caso di SEEK_END non è possibile portare in avanti il puntatore. Nel caso di SEEK_CUR, è possibile spostarsi in avanti e all'indietro, sempre nella limite della dimensione del file. Qualunque sia la scelta, è necessario modificare la posizione del puntatore e l'indice del blocco dati.